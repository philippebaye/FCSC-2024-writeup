from pwn import *

'''
Public key:
p = 22916263974321496608526706139268946131219178523495948278763580919130250527783125740278292394673545866539834007603474130794580451317100933414795635637107243009325412192819042752376677927711961511593091562876852564499724220198459165397244683718884657775823827348074904670093858793897828645111777559864875148426029905287332004697881306096003563503401610337494717060337206030724186733628906081114752633642901035389286761465627695420155886250941837412074873006932489337372372927416855196376579866746261441285126483764283213307977064151028613867637806978231705972433374334467880502586614924714252640932711354675063591482273
g = 2
y = 10087903532108934179404843966570796860659327569036703289934023857101663633140122933023869380975103592414278665183812663014950055387448843196017543814397142459437788849063299971390420401090179343210141501470247076822963665530430555083145064395903274981019633463037714678429175000068005683698010374396135712695888651144610538456003422956916613009769375097104799643890409568620853228300865811558311279161003495339569756444974040691824574375224420552149384204657812558711478930989729853340939722135003496881071817507236129994391522618814465007546199651448228713157122202940036394733072122854837307581937574667181221233315
Your task is to sign the following message m = 3650605428126354666887676296693776474159421486248984815143421106899732353643378300419727176322675720311214591178614362970122197338619239252656747130560756275268666594948884988304337422628721185214412904571119456332250596438251646190725927397575449278917761459688473876355132545639589647695194650930618883411292225127671615594886295149141514067235048635120932557907413898003916531416904930871632685690418510440964489504619776285066073606173095309411125338750964861250608534038768594129927711228805547263135352850511334293748663202984102683284686875677963745022932798102444332128030308700718142824500827955463444837155
Input a signature. First, input r.
>>> 4708185002478754870936517153471111811889614829173638282235632370524463437717584253193541055114008470212243857614544061247739246645607622837444516362592857548491095110927139231038563488103557258985100625822183912721403429756347026506737700296506732729522918987239475045687064428299547158981412463342467198402928530111925397720522273014283587551786668725599080312999923402943369664063614784601395142012375430774323234591088241768213721672470546456598914177609208703434884418523809305095055283486107556629567023442012095906585438128294006295208957431846318839823575466567044792610244522659246883144050046850357042552876
Now, input s.
>>> 4708185002478754870936517153471111811889614829173638282235632370524463437717584253193541055114008470212243857614544061247739246645607622837444516362592857548491095110927139231038563488103557258985100625822183912721403429756347026506737700296506732729522918987239475045687064428299547158981412463342467198402928530111925397720522273014283587551786668725599080312999923402943369664063614784601395142012375430774323234591088241768213721672470546456598914177609208703434884418523809305095055283486107556629567023442012095906585438128294006295208957431846318839823575466567044792610244522659246883144050046850357042552876
Congratulations! The message and signature match. Here is your flag:
FCSC{...}
'''

host, port = "challenges.france-cybersecurity-challenge.fr", "2152"

if args.REMOTE:
  processus = remote(host,port)
else:
  processus = process(['python3', 'el-gamal-fait-2.py'])

data = processus.recvline().decode()
log.info(data)

# Récupération d'une donnée au format var = val
def recup_data():
  data = processus.recvline().decode()
  log.info(data)
  var, val = data.split('=')
  val = int(val)
  print(f'{var} = {val}')
  return val

p = recup_data()
g = recup_data()
y = recup_data()
m = recup_data()


# ================================================
# Détermination si résidu quadratique
# ================================================
def est_residu_n_quadratique(valeur, n, premier):
  if (premier % (2**n) != 1):
    print(f"p n'est pas égal à 1 modulo {n**2} !!")
    quit()
  return pow(valeur, (premier -1)//(2**n), premier) == 1

# pow(valeur, (premier-1)//2, premier)
def est_residu_quadratique(valeur, premier):
  return est_residu_n_quadratique(valeur, 1, premier)

def trouver_1er_residu_non_quadratique(valeur, premier):
  for i in range(1, p):
    if not est_residu_n_quadratique(valeur, i, premier):
      return i
  else:
    print('pas de residu trouvé !!!')
    return None


# ================================================
# Détermination du cas en fonction des inputs fournis dans l'énoncé
# ================================================
# y résidu quadratique ?
y_est_carre = est_residu_quadratique(y, p)
y_pas_carre = not y_est_carre

# parité de m
m_est_pair = (m & 1 == 0)
m_pas_pair = not m_est_pair

# ================================================
# Calcul des valeurs à fournir
# ================================================
r = (p-1)//2

if (y_est_carre and m_est_pair) or (y_pas_carre and m_pas_pair):
  s = (p-1)-m
elif (i := trouver_1er_residu_non_quadratique(g, p)):
  s = (p-1)//(2**i) -m 
else:
  print('cas non géré par cet algo !!!')
  quit()

'''
if y_est_carre:
  if m_est_pair:
    s = (p-1)-m
  elif not g_est_carre:
    s = (p-1)//2 - m
  else:
    g_est_double_carre = (pow(g, (p-1)//4, p) == 1)
    if not g_est_double_carre:
      s = (p-1)//4 - m
    else:
      print('cas 1 non géré par cet algo !!!')
      quit()
else:
  if not m_est_pair:
    s = (p-1)-m
  elif not g_est_carre:
    s = (p-1)//2 - m
  else:
    # raccourci : on suppose que la racine de g n'est alors pas un résidu quadratique
    # sinon il faudrait renouveler l'opération, tant que ce n'est pas le cas.
    # 
    # comme on a pris p tel que p = 1 [4], on a p = 1 + 4k, donc on peut faire (p-1)/4 = k
    # 
    # sans être obligé de faire le calcul de racine, on peut directement vérifier si pow(g, (p-1)/4, p) = -1 [p]
    g_est_double_carre = (pow(g, (p-1)//4, p) == 1)
    if not g_est_double_carre:
      s = (p-1)//4 - m
    else:
      print('cas 2 non géré par cet algo !!!')
      quit()
'''

# Fourniture des inputs
def send_input(val):
  data = processus.recvuntil(b'>>> ').decode()
  val = str(val)
  log.info(data + val)
  processus.sendline(val.encode())

send_input(r)
send_input(s)

# Récupération du flag
datas = processus.recvlinesS(2)
[log.info(data) for data in datas]

processus.close()
